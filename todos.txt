A. Project structure refinement

Goal: one top-level entry script + an internal modules/ package that hides all complexity.

1. Create an internal package directory

    Name it something like modules/.

    This will contain all logic currently spread across top-level scripts.

2. Group existing code into logical submodules under modules/

    Move CARLA loop and simulation orchestration (currently in LaneKeepMain) into a submodule, for example modules/simulator/.

    Move LKAS control logic (from Controller) into modules/controller/.

    Move lane detection logic:

    legacy detector (from lane_detect)

    LaneNet wrapper and model (from lanenet/)
    into modules/perception/.

    Move HUD / visualization utilities (from vehicle_hud) into modules/hud/.

    Move generic helpers (from utils, and any reusable bits from analysis) into modules/utils/.

    Keep any analysis-specific utilities (if needed) in something like modules/analysis/.

3. Leave the repo root minimal

    One main runner script: run_sim.py.

    configs/ directory with example JSON configs.

    Optional results/ directory as the default output root (or create it on the fly).

    README.md and environment/requirements files only.

4. Make the simulator callable via a single internal “runner”

    Inside modules/, define one central entry function that:

        Receives a configuration object.

        Sets up CARLA connection.

        Builds the perception + controller stack.

        Runs the simulation loop for the configured duration.

        Honors HUD and logging settings.

    All higher-level behavior (single run vs experiment) should go through this.

B. Config design (what the JSON must express)

Goal: one JSON format that supports both a simple demo run and multi-run experiments.

Define a single schema with these top-level sections:

1. simulation

    What it should contain:

        Map/town identifier (for example, which CARLA town to load).

        Simulation run distance (in meters)

        Optional fixed random seed (for reproducibility).

    Acts as global defaults for all runs in a config.

2. environment

    What it should contain: target speed, Weather preset name (matching whatever your existing weather handling understands), street light, vehicle light.

    Can be overridden per condition in experiment mode.

3. lkas

    What it should contain: Lane detector type (e.g., legacy vs LaneNet).

    Use this to avoid hard-coded controller settings in the code.

4. display

    What it should contain: A boolean flag indicating whether to show the HUD.

    The simulator should check this to decide whether to construct and update HUD-related objects.

5. logging

    What it should contain:

        A boolean flag to enable or disable any file output.

    For the demo config:

        Logging disabled.

    For experiments:

        Logging enabled so existing output behavior continues.

6. experiment

    What it should contain:

        A mode field with at least two values:

            Single-run mode (for demo).

            Multi-run mode (for experiments).

    A descriptive name for the experiment (used purely as a label).

    For multi-run settings:

        An explicit list of seeds.

        A list of conditions, where each condition can override:

            Environment settings.

            LKAS settings.

    In single mode:

        No conditions list needed; just use the top-level simulation, environment, and lkas.

C. Specific configs you want

1. Demo config

    Purpose: one run, no logs, quick visual demonstration.

    Characteristics:

        Experiment mode set to single.

        One map, one weather.

        Lane detector (legacy).

        Simulation duration fixed 1000 meters.

        Display section set to show or hide HUD as you prefer for the demo.

        Logging section explicitly disabled.

Experiment config

    Purpose: reproduce paper-style experiments with multiple runs and conditions.

    Characteristics:

        Experiment mode set to multi.

        Name describing the experiment (e.g., weather sensitivity).

        Global simulation defaults (simulation distance, base map).

        Optional global LKAS defaults.

        Display section likely set to hide HUD (to avoid interactive overhead), but configurable.

        Logging section enabled, so existing output behavior is preserved.

        Conditions list where each condition:

            Has a label.

            Overrides environment and/or LKAS fields to define each scenario.

    A field that controls how many runs to perform per condition, or a list of seeds.

D. Behavior to wire up around these configs

Codex can take this as guidance:

1. Single-run behavior

    When the config’s experiment mode is single:

    Read the top-level simulation, environment, lkas, display, logging.

    Run the simulator exactly once using those values.

    If logging is disabled, skip any file-writes the current code does (or route them to a no-op).

2. Multi-run experiment behavior

    When the config’s experiment mode is multi:

        For each condition:

    Merge condition-specific overrides with top-level defaults.

    For each run (controlled by num-runs or seeds):

        Run the simulator once with those merged settings.

        Allow the existing logging to produce outputs in the existing style/location.

    Optionally, emit a simple in-memory summary in the end, but that is secondary.

HUD handling

    Before creating or updating HUD objects:

        Check the display section’s show-hud flag.

        Create and update HUD only if it is enabled.

    Ensure the main loop is safe when HUD is disabled (no calls to HUD methods when there is none).
